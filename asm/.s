;
; File generated by cc65 v 2.16 - Git N/A
;
	.fopt		compiler,"cc65 v 2.16 - Git N/A"
	.setcpu		"6502"
	.smart		on
	.autoimport	on
	.case		on
	.debuginfo	off
	.importzp	sp, sreg, regsave, regbank
	.importzp	tmp1, tmp2, tmp3, tmp4, ptr1, ptr2, ptr3, ptr4
	.macpack	longbranch
	.import		_oam_spr
	.import		_oam_meta_spr
	.import		_vram_adr
	.import		_vram_put
	.export		_spr
	.export		_metaspr
	.export		_move_rect
	.export		_point_in_rect
	.export		_rect_collides
	.export		_digit_update
	.export		_digit_increment
	.export		_nt_print

; ---------------------------------------------------------------
; void __near__ __fastcall__ spr (__near__ const struct sprite *, __near__ unsigned char *)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_spr: near

.segment	"CODE"

;
; {
;
	jsr     pushax
;
; *oam_ptr = oam_spr(sprite->x, 
;
	jsr     pushw0sp
	jsr     decsp4
	ldy     #$09
	lda     (sp),y
	sta     ptr1+1
	dey
	lda     (sp),y
	sta     ptr1
	ldy     #$03
	lda     (ptr1),y
	sta     (sp),y
;
; sprite->y, 
;
	ldy     #$09
	lda     (sp),y
	sta     ptr1+1
	dey
	lda     (sp),y
	sta     ptr1
	ldy     #$00
	lda     (ptr1),y
	ldy     #$02
	sta     (sp),y
;
; sprite->tile_index, 
;
	ldy     #$09
	lda     (sp),y
	sta     ptr1+1
	dey
	lda     (sp),y
	sta     ptr1
	ldy     #$01
	lda     (ptr1),y
	sta     (sp),y
;
; 0, 
;
	lda     #$00
	dey
	sta     (sp),y
;
; *oam_ptr);
;
	ldy     #$07
	lda     (sp),y
	sta     ptr1+1
	dey
	lda     (sp),y
	sta     ptr1
	ldy     #$00
	lda     (ptr1),y
	jsr     _oam_spr
	ldy     #$00
	jsr     staspidx
;
; }
;
	jmp     incsp4

.endproc

; ---------------------------------------------------------------
; void __near__ __fastcall__ metaspr (__near__ const struct metasprite *, __near__ unsigned char *)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_metaspr: near

.segment	"CODE"

;
; {
;
	jsr     pushax
;
; *oam_ptr = oam_meta_spr(metasprite->x, 
;
	jsr     pushw0sp
	jsr     decsp3
	ldy     #$08
	lda     (sp),y
	sta     ptr1+1
	dey
	lda     (sp),y
	sta     ptr1
	ldy     #$00
	lda     (ptr1),y
	ldy     #$02
	sta     (sp),y
;
; metasprite->y, 
;
	ldy     #$08
	lda     (sp),y
	sta     ptr1+1
	dey
	lda     (sp),y
	sta     ptr1
	ldy     #$01
	lda     (ptr1),y
	sta     (sp),y
;
; *oam_ptr, 
;
	ldy     #$06
	lda     (sp),y
	sta     ptr1+1
	dey
	lda     (sp),y
	sta     ptr1
	ldy     #$00
	lda     (ptr1),y
	sta     (sp),y
;
; metasprite->index_buffer);
;
	ldy     #$08
	lda     (sp),y
	sta     ptr1+1
	dey
	lda     (sp),y
	sta     ptr1
	ldy     #$03
	lda     (ptr1),y
	tax
	dey
	lda     (ptr1),y
	jsr     _oam_meta_spr
	ldy     #$00
	jsr     staspidx
;
; }
;
	jmp     incsp4

.endproc

; ---------------------------------------------------------------
; void __near__ __fastcall__ move_rect (__near__ struct rect *, unsigned char, unsigned char)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_move_rect: near

.segment	"CODE"

;
; {
;
	jsr     pusha
;
; rect->x = x;
;
	ldy     #$03
	lda     (sp),y
	sta     ptr1+1
	dey
	lda     (sp),y
	sta     ptr1
	dey
	lda     (sp),y
	dey
	sta     (ptr1),y
;
; rect->y = y;
;
	ldy     #$03
	lda     (sp),y
	sta     ptr1+1
	dey
	lda     (sp),y
	sta     ptr1
	ldy     #$00
	lda     (sp),y
	iny
	sta     (ptr1),y
;
; rect->max_x = rect->x + rect->w;
;
	ldy     #$05
	jsr     pushwysp
	ldy     #$05
	lda     (sp),y
	sta     ptr1+1
	dey
	lda     (sp),y
	sta     ptr1
	ldx     #$00
	lda     (ptr1,x)
	jsr     pusha0
	ldy     #$07
	lda     (sp),y
	sta     ptr1+1
	dey
	lda     (sp),y
	sta     ptr1
	ldy     #$02
	lda     (ptr1),y
	jsr     tosadda0
	ldy     #$04
	jsr     staspidx
;
; rect->max_y = rect->y + rect->h;
;
	ldy     #$05
	jsr     pushwysp
	ldy     #$05
	lda     (sp),y
	sta     ptr1+1
	dey
	lda     (sp),y
	sta     ptr1
	ldy     #$01
	lda     (ptr1),y
	jsr     pusha0
	ldy     #$07
	lda     (sp),y
	sta     ptr1+1
	dey
	lda     (sp),y
	sta     ptr1
	ldy     #$03
	lda     (ptr1),y
	jsr     tosadda0
	ldy     #$05
	jsr     staspidx
;
; }
;
	jmp     incsp4

.endproc

; ---------------------------------------------------------------
; unsigned char __near__ __fastcall__ point_in_rect (__near__ const struct rect *, unsigned char, unsigned char)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_point_in_rect: near

.segment	"CODE"

;
; {
;
	jsr     pusha
;
; return (x > rect->x && y > rect->y && x < rect->max_x && y < rect->max_y);
;
	ldy     #$01
	lda     (sp),y
	jsr     pusha0
	ldy     #$05
	lda     (sp),y
	sta     ptr1+1
	dey
	lda     (sp),y
	sta     ptr1
	lda     (ptr1,x)
	jsr     tosicmp0
	bcc     L001D
	beq     L001D
	ldx     #$00
	lda     (sp,x)
	jsr     pusha0
	ldy     #$05
	lda     (sp),y
	sta     ptr1+1
	dey
	lda     (sp),y
	sta     ptr1
	ldy     #$01
	lda     (ptr1),y
	jsr     tosicmp0
	bcc     L001D
	beq     L001D
	ldy     #$01
	lda     (sp),y
	jsr     pusha0
	ldy     #$05
	lda     (sp),y
	sta     ptr1+1
	dey
	lda     (sp),y
	sta     ptr1
	lda     (ptr1),y
	jsr     tosicmp0
	bcs     L001D
	ldx     #$00
	lda     (sp,x)
	jsr     pusha0
	ldy     #$05
	lda     (sp),y
	sta     ptr1+1
	dey
	lda     (sp),y
	sta     ptr1
	iny
	lda     (ptr1),y
	jsr     tosicmp0
	bcc     L001C
L001D:	ldx     #$00
	txa
	jmp     incsp4
L001C:	lda     #$01
	ldx     #$00
;
; }
;
	jmp     incsp4

.endproc

; ---------------------------------------------------------------
; unsigned char __near__ __fastcall__ rect_collides (__near__ const struct rect *, __near__ const struct rect *)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_rect_collides: near

.segment	"CODE"

;
; {
;
	jsr     pushax
;
; return (first->x < second->max_x && 
;
	ldy     #$03
	lda     (sp),y
	sta     ptr1+1
	dey
	lda     (sp),y
	sta     ptr1
	ldx     #$00
	lda     (ptr1,x)
	jsr     pusha0
	ldy     #$03
	lda     (sp),y
	sta     ptr1+1
	dey
	lda     (sp),y
	sta     ptr1
	ldy     #$04
	lda     (ptr1),y
	jsr     tosicmp0
	bcs     L0022
;
; first->max_x > second->x &&
;
	ldy     #$03
	lda     (sp),y
	sta     ptr1+1
	dey
	lda     (sp),y
	sta     ptr1
	ldy     #$04
	lda     (ptr1),y
	jsr     pusha0
	ldy     #$03
	lda     (sp),y
	sta     ptr1+1
	dey
	lda     (sp),y
	sta     ptr1
	lda     (ptr1,x)
	jsr     tosicmp0
	bcc     L0022
	beq     L0022
;
; first->y < second->max_y && 
;
	ldy     #$03
	lda     (sp),y
	sta     ptr1+1
	dey
	lda     (sp),y
	sta     ptr1
	dey
	lda     (ptr1),y
	jsr     pusha0
	ldy     #$03
	lda     (sp),y
	sta     ptr1+1
	dey
	lda     (sp),y
	sta     ptr1
	ldy     #$05
	lda     (ptr1),y
	jsr     tosicmp0
	bcs     L0022
;
; first->max_y > second->y);
;
	ldy     #$03
	lda     (sp),y
	sta     ptr1+1
	dey
	lda     (sp),y
	sta     ptr1
	ldy     #$05
	lda     (ptr1),y
	jsr     pusha0
	ldy     #$03
	lda     (sp),y
	sta     ptr1+1
	dey
	lda     (sp),y
	sta     ptr1
	dey
	lda     (ptr1),y
	jsr     tosicmp0
	beq     L0022
	bcs     L0021
L0022:	ldx     #$00
	txa
	jmp     incsp4
L0021:	lda     #$01
	ldx     #$00
;
; }
;
	jmp     incsp4

.endproc

; ---------------------------------------------------------------
; void __near__ __fastcall__ digit_update (__near__ struct digits *)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_digit_update: near

.segment	"DATA"

L0025:
	.byte	$00

.segment	"CODE"

;
; {
;
	jsr     pushax
;
; for (i = 0; i < 6; ++i)
;
	lda     #$00
	sta     L0025
L005A:	lda     L0025
	cmp     #$06
	bcs     L0028
;
; if (digits->segments[i] > 9)
;
	ldy     #$01
	lda     (sp),y
	tax
	dey
	lda     (sp),y
	ldy     L0025
	sta     ptr1
	stx     ptr1+1
	lda     (ptr1),y
	cmp     #$0A
	bcc     L005B
;
; digits->segments[i]    = 0;
;
	ldy     #$01
	lda     (sp),y
	tax
	dey
	lda     (sp),y
	clc
	adc     L0025
	bcc     L0058
	inx
L0058:	sta     ptr1
	stx     ptr1+1
	tya
	sta     (ptr1),y
;
; digits->segments[i+1] += 1;
;
	tax
	lda     L0025
	clc
	adc     #$01
	bcc     L0059
	inx
	clc
L0059:	adc     (sp),y
	sta     ptr1
	txa
	iny
	adc     (sp),y
	sta     ptr1+1
	dey
	lda     (ptr1),y
	clc
	adc     #$01
	sta     (ptr1),y
;
; for (i = 0; i < 6; ++i)
;
L005B:	inc     L0025
	jmp     L005A
;
; if (digits->segments[7] > 9)
;
L0028:	ldy     #$01
	lda     (sp),y
	sta     ptr1+1
	dey
	lda     (sp),y
	sta     ptr1
	ldy     #$07
	lda     (ptr1),y
	cmp     #$0A
	bcc     L0039
;
; digits->segments[7] = 9;
;
	ldy     #$01
	lda     (sp),y
	sta     ptr1+1
	dey
	lda     (sp),y
	sta     ptr1
	lda     #$09
	ldy     #$07
	sta     (ptr1),y
;
; }
;
L0039:	jmp     incsp2

.endproc

; ---------------------------------------------------------------
; void __near__ __fastcall__ digit_increment (__near__ struct digits *, signed char)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_digit_increment: near

.segment	"CODE"

;
; {
;
	jsr     pusha
;
; digits->segments[0] += amt;
;
	ldy     #$02
	lda     (sp),y
	tax
	dey
	lda     (sp),y
	jsr     pushax
	sta     ptr1
	stx     ptr1+1
	ldy     #$00
	lda     (ptr1),y
	sta     ptr1
	ldy     #$02
	lda     (sp),y
	clc
	adc     ptr1
	ldy     #$00
	jsr     staspidx
;
; digit_update(digits);
;
	ldy     #$02
	lda     (sp),y
	tax
	dey
	lda     (sp),y
	jsr     _digit_update
;
; }
;
	jmp     incsp3

.endproc

; ---------------------------------------------------------------
; void __near__ __fastcall__ nt_print (unsigned int, __near__ const unsigned char *)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_nt_print: near

.segment	"CODE"

;
; {
;
	jsr     pushax
;
; vram_adr(adr);
;
	ldy     #$03
	lda     (sp),y
	tax
	dey
	lda     (sp),y
	jsr     _vram_adr
;
; if (!(*str)) break;
;
L0049:	ldy     #$01
	lda     (sp),y
	sta     ptr1+1
	dey
	lda     (sp),y
	sta     ptr1
	lda     (ptr1),y
	beq     L004A
;
; vram_put((*str++)+ASCII_OFFSET);
;
	iny
	lda     (sp),y
	tax
	dey
	lda     (sp),y
	sta     regsave
	stx     regsave+1
	clc
	adc     #$01
	bcc     L0053
	inx
L0053:	jsr     stax0sp
	ldy     #$00
	lda     (regsave),y
	sec
	sbc     #$20
	jsr     _vram_put
;
; while(1)
;
	jmp     L0049
;
; }
;
L004A:	jmp     incsp4

.endproc

